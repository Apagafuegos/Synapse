use super::{AnalysisReport, OutputGenerator};
use anyhow::Result;

pub struct ConsoleOutput;

impl OutputGenerator for ConsoleOutput {
    fn generate(&self, report: &AnalysisReport) -> Result<String> {
        Ok(self.generate_console(report))
    }
    
    fn file_extension(&self) -> &str {
        "txt"
    }
}

impl ConsoleOutput {
    fn generate_console(&self, report: &AnalysisReport) -> String {
        let header = self.header(&report.metadata);
        let stats = self.stats(&report.stats);
        let analysis = self.analysis(&report.analysis);
        let logs = self.logs(&report.logs);
        let timestamp = &report.metadata.timestamp;
        
        format!(
            "{}\n\n{}\n\n{}\n\n{}\n\n---\nGenerated by Synapse on {}",
            header, stats, analysis, logs, timestamp
        )
    }
    
    fn header(&self, metadata: &super::ReportMetadata) -> String {
        let width = 60;
        let border = "═".repeat(width);
        
        format!(
            "╔{}╗\n║                    LOGLENS ANALYSIS REPORT                     ║\n╠{}╣\n║  Generated:  {:<50} ║\n║  Provider:   {:<50} ║\n║  Log Level:  {:<50} ║\n║  Input:      {:<50} ║\n║  Total Logs: {:<50} ║\n╚{}╝",
            border,
            "═".repeat(width),
            metadata.timestamp,
            metadata.provider,
            metadata.log_level,
            metadata.input_source,
            metadata.total_logs.to_string(),
            border
        )
    }
    
    fn stats(&self, stats: &super::ReportStats) -> String {
        format!(
            "STATISTICS
STATISTICS\n┌─────────────────────────────────────────────────────────────────┐\n│  Errors:    {:<42} Warnings:  {:<10} │\n│  Info:       {:<42} Debug:     {:<10} │\n│  Unique:     {:<42}            │\n└─────────────────────────────────────────────────────────────────┘",
            stats.error_count.to_string(),
            stats.warning_count.to_string(),
            stats.info_count.to_string(),
            stats.debug_count.to_string(),
            stats.unique_messages.to_string()
        )
    }
    
    fn analysis(&self, analysis: &super::AnalysisResponse) -> String {
        format!(
            "ANALYSIS RESULTS

ANALYSIS RESULTS\n\nSEQUENCE OF EVENTS:
SEQUENCE OF EVENTS:\n{}\n\nROOT CAUSE:
ROOT CAUSE:\n{}\n\nLOCATION:
LOCATION:\n{}",
            self.wrap_text(&analysis.sequence_of_events, 60),
            self.wrap_text(&analysis.root_cause.description, 60),
            self.wrap_text(analysis.root_cause.file_location.as_deref().unwrap_or("Unknown"), 60)
        )
    }
    
    fn logs(&self, logs: &[super::ProcessedLogEntry]) -> String {
        if logs.is_empty() {
            return "\nLOG ENTRIES
LOG ENTRIES\n\nNo log entries found.".to_string();
        }
        
        let mut result = format!("\nLOG ENTRIES
LOG ENTRIES ({} entries)\n\n", logs.len());
        
        for (i, log) in logs.iter().take(10).enumerate() { // Show first 10 entries
            result.push_str(&format!(
                "{} {} {}\n",
                self.format_index(i + 1),
                self.format_level(log.level.as_deref().unwrap_or("UNKNOWN")),
                self.format_timestamp(log.timestamp.as_deref())
            ));
            
            result.push_str(&self.wrap_text(&log.message, 50));
            result.push_str("\n\n");
        }
        
        if logs.len() > 10 {
            result.push_str(&format!("... and {} more entries\n", logs.len() - 10));
        }
        
        result
    }
    
    fn wrap_text(&self, text: &str, width: usize) -> String {
        let mut result = String::new();
        let mut line = String::new();
        
        for word in text.split_whitespace() {
            if line.len() + word.len() < width {
                if !line.is_empty() {
                    line.push(' ');
                }
                line.push_str(word);
            } else {
                if !line.is_empty() {
                    result.push_str(&line);
                    result.push('\n');
                }
                line = word.to_string();
            }
        }
        
        if !line.is_empty() {
            result.push_str(&line);
        }
        
        result
    }
    
    fn format_index(&self, index: usize) -> String {
        format!("{:2}.", index)
    }
    
    fn format_level(&self, level: &str) -> String {
        match level {
            "ERROR" => "ERROR".to_string(),
            "WARN" | "WARNING" => "WARN".to_string(),
            "INFO" => "INFO".to_string(),
            "DEBUG" => "DEBUG".to_string(),
            _ => format!("{}", level),
        }
    }
    
    fn format_timestamp(&self, timestamp: Option<&str>) -> String {
        match timestamp {
            Some(ts) => format!("{}", ts),
            None => "No timestamp".to_string(),
        }
    }
}