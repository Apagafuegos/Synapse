use super::{AnalysisReport, OutputGenerator};
use anyhow::Result;

pub struct MarkdownOutput;

impl OutputGenerator for MarkdownOutput {
    fn generate(&self, report: &AnalysisReport) -> Result<String> {
        Ok(self.generate_markdown(report))
    }
    
    fn file_extension(&self) -> &str {
        "md"
    }
}

impl MarkdownOutput {
    fn generate_markdown(&self, report: &AnalysisReport) -> String {
        format!(
            r#"# Synapse Analysis Report

*Generated on {}*

## Metadata

| Key | Value |
|-----|-------|
| **Provider** | {} |
| **Log Level** | {} |
| **Input Source** | {} |
| **Total Logs** | {} |
| **Filtered Logs** | {} |

## Statistics

| Metric | Count |
|--------|-------|
| **Errors** | {} |
| **Warnings** | {} |
| **Info** | {} |
| **Debug** | {} |
| **Unique Messages** | {} |

## Analysis Results

### Sequence of Events

{}

### Error Details

{}

### Failed Component

{}

## Log Entries

{}

---
*Report generated by Synapse*"#,
            report.metadata.timestamp,
            report.metadata.provider,
            report.metadata.log_level,
            report.metadata.input_source,
            report.metadata.total_logs,
            report.metadata.filtered_logs,
            report.stats.error_count,
            report.stats.warning_count,
            report.stats.info_count,
            report.stats.debug_count,
            report.stats.unique_messages,
            report.analysis.sequence_of_events,
            report.analysis.root_cause.description,
            report.analysis.root_cause.file_location.as_deref().unwrap_or("Unknown"),
            self.render_logs(&report.logs)
        )
    }
    
    fn render_logs(&self, logs: &[super::ProcessedLogEntry]) -> String {
        if logs.is_empty() {
            return "*No log entries found.*".to_string();
        }
        
        let mut result = String::new();
        
        for (i, log) in logs.iter().enumerate() {
            result.push_str(&format!(
                "### {}. {}\n\n",
                i + 1,
                self.format_log_header(log)
            ));
            
            result.push_str("```\n");
            result.push_str(&log.message);
            result.push_str("\n```\n\n");
        }
        
        result
    }
    
    fn format_log_header(&self, log: &super::ProcessedLogEntry) -> String {
        let level = log.level.as_deref().unwrap_or("UNKNOWN");
        let timestamp = log.timestamp.as_deref().unwrap_or("No timestamp");
        
        format!("**{}** | {}", timestamp, level)
    }
}