import type { LogParseResult, LogLevel } from '@/types';

// WASM module interface - matches generated bindings
interface LogLensWasm {
  main(): void;
  init_streaming(): void;
  parse_log_preview(content: string, maxLines: number): any;
  filter_logs_by_level(content: string, minLevel: string): string;
  count_log_levels(content: string): any;
  count_log_levels_optimized(content: string): any;
  parse_log_streaming(content: string, chunkSize: number, maxLines: number): any;
  search_logs(content: string, query: string, caseSensitive: boolean): any;
  get_performance_stats(): any;
}

class WasmService {
  private wasmModule: LogLensWasm | null = null;
  private initPromise: Promise<void> | null = null;

  constructor() {
    this.initPromise = this.initialize();
  }

  private async initialize(): Promise<void> {
    try {
      console.log('[WASM] Loading LogLens WASM module...');

      // Import the WASM module generated by wasm-pack
      const wasmModule = await import('../../../../loglens-wasm/pkg/loglens_wasm');

      // Initialize the WASM module and call main() to set up the module
      await wasmModule.default();
      wasmModule.main();
      wasmModule.init_streaming();

      this.wasmModule = wasmModule as LogLensWasm;
      console.log('[WASM] LogLens WASM module loaded successfully');
    } catch (error) {
      console.warn('[WASM] WASM module not available, using JavaScript fallbacks:', error);
      // Don't throw - WASM is optional, the app works without it with JavaScript fallbacks
      this.wasmModule = null;
    }
  }

  private async ensureInitialized(): Promise<LogLensWasm | null> {
    if (!this.initPromise) {
      this.initPromise = this.initialize();
    }

    await this.initPromise;

    // Return null if WASM not available (instead of throwing)
    return this.wasmModule;
  }

  async parseLogPreview(content: string, maxLines: number = 1000): Promise<LogParseResult> {
    const wasm = await this.ensureInitialized();

    // If WASM not available, return basic parsed result
    if (!wasm) {
      console.log('[WASM] WASM not available, using JavaScript fallback for parsing');
      const allLines = content.split('\n');
      const lines = allLines.slice(0, maxLines);

      // Count lines by level
      let errorLines = 0;
      let warningLines = 0;
      let infoLines = 0;
      let debugLines = 0;

      const linesByLevel = lines.map((line, index) => {
        const level = this.detectLogLevel(line);

        // Count by level
        if (level === 'ERROR') errorLines++;
        else if (level === 'WARN') warningLines++;
        else if (level === 'INFO') infoLines++;
        else if (level === 'DEBUG') debugLines++;

        return {
          line_number: index + 1,
          level: level,
          timestamp: logUtils.parseTimestamp(line)?.toISOString(),
          message: line,
          is_truncated: false,
        };
      });

      return {
        total_lines: lines.length,
        error_lines: errorLines,
        warning_lines: warningLines,
        info_lines: infoLines,
        debug_lines: debugLines,
        lines_by_level: linesByLevel,
      };
    }

    try {
      console.log(`[WASM] Parsing log preview: ${content.length} chars, max ${maxLines} lines`);
      const startTime = performance.now();

      // Use the optimized streaming parser for better performance
      const chunkSize = Math.min(1000, Math.max(100, Math.floor(content.length / 100)));
      const result = wasm.parse_log_streaming(content, chunkSize, maxLines);

      const endTime = performance.now();
      console.log(`[WASM] Streaming parsing completed in ${(endTime - startTime).toFixed(2)}ms`);

      return result as LogParseResult;
    } catch (error) {
      console.error('[WASM] Log parsing failed:', error);
      // Fallback to basic parsing if streaming fails
      try {
        const result = wasm.parse_log_preview(content, maxLines);
        return result as LogParseResult;
      } catch (fallbackError) {
        throw new Error(`Failed to parse logs: ${error}`);
      }
    }
  }

  private detectLogLevel(line: string): string | undefined {
    const upperLine = line.toUpperCase();
    if (upperLine.includes('ERROR') || upperLine.includes('[ERR]')) return 'ERROR';
    if (upperLine.includes('WARN') || upperLine.includes('[WRN]')) return 'WARN';
    if (upperLine.includes('INFO') || upperLine.includes('[INF]')) return 'INFO';
    if (upperLine.includes('DEBUG') || upperLine.includes('[DBG]')) return 'DEBUG';
    return undefined;
  }

  async filterLogsByLevel(content: string, minLevel: LogLevel): Promise<string> {
    const wasm = await this.ensureInitialized();

    // If WASM not available, use JavaScript fallback
    if (!wasm) {
      console.log('[WASM] WASM not available, using JavaScript fallback for filtering');
      const lines = content.split('\n');
      const filtered = lines.filter(line => {
        const level = this.detectLogLevel(line);
        if (!level) return true; // Keep lines without clear level
        return this.compareLevels(level, minLevel) >= 0;
      });
      return filtered.join('\n');
    }

    try {
      console.log(`[WASM] Filtering logs by level: ${minLevel}`);
      const startTime = performance.now();

      const filtered = wasm.filter_logs_by_level(content, minLevel);

      const endTime = performance.now();
      console.log(`[WASM] Filtering completed in ${(endTime - startTime).toFixed(2)}ms`);

      return filtered;
    } catch (error) {
      console.error('[WASM] Log filtering failed:', error);
      throw new Error(`Failed to filter logs: ${error}`);
    }
  }

  private compareLevels(level1: string, level2: string): number {
    const levels = ['DEBUG', 'INFO', 'WARN', 'ERROR'];
    return levels.indexOf(level1.toUpperCase()) - levels.indexOf(level2.toUpperCase());
  }

  async countLogLevels(content: string): Promise<Record<string, number>> {
    const wasm = await this.ensureInitialized();

    // If WASM not available, use JavaScript fallback
    if (!wasm) {
      console.log('[WASM] WASM not available, using JavaScript fallback for counting');
      const counts: Record<string, number> = { ERROR: 0, WARN: 0, INFO: 0, DEBUG: 0 };
      const lines = content.split('\n');
      for (const line of lines) {
        const level = this.detectLogLevel(line);
        if (level && counts[level] !== undefined) {
          counts[level]++;
        }
      }
      return counts;
    }

    try {
      console.log('[WASM] Counting log levels');
      const startTime = performance.now();

      // Use the optimized counting function
      const result = wasm.count_log_levels_optimized(content);

      const endTime = performance.now();
      console.log(`[WASM] Optimized counting completed in ${(endTime - startTime).toFixed(2)}ms`);

      return result as Record<string, number>;
    } catch (error) {
      console.error('[WASM] Log counting failed:', error);
      // Fallback to basic counting
      try {
        const result = wasm.count_log_levels(content);
        return result as Record<string, number>;
      } catch (fallbackError) {
        throw new Error(`Failed to count log levels: ${error}`);
      }
    }
  }

  async searchLogs(
    content: string,
    query: string,
    caseSensitive: boolean = false
  ): Promise<string[]> {
    if (!query.trim()) {
      return [];
    }

    const wasm = await this.ensureInitialized();

    // If WASM not available, use JavaScript fallback
    if (!wasm) {
      console.log('[WASM] WASM not available, using JavaScript fallback for search');
      const searchQuery = caseSensitive ? query : query.toLowerCase();
      const lines = content.split('\n');
      return lines.filter(line => {
        const searchLine = caseSensitive ? line : line.toLowerCase();
        return searchLine.includes(searchQuery);
      });
    }

    try {
      console.log(`[WASM] Searching logs for: "${query}"`);
      const startTime = performance.now();

      const result = wasm.search_logs(content, query, caseSensitive);
      const matches = result as string[];

      const endTime = performance.now();
      console.log(`[WASM] Search completed in ${(endTime - startTime).toFixed(2)}ms, ${matches.length} matches`);

      return matches;
    } catch (error) {
      console.error('[WASM] Log search failed:', error);
      throw new Error(`Failed to search logs: ${error}`);
    }
  }

  async getMemoryUsage(): Promise<{ used: number; total: number }> {
    const wasm = await this.ensureInitialized();

    // If WASM not available, return zero
    if (!wasm) {
      return { used: 0, total: 0 };
    }

    try {
      // Get performance stats from WASM module which may include memory info
      const stats = wasm.get_performance_stats();
      if (stats && stats.memory_mb) {
        return {
          used: stats.memory_mb,
          total: stats.memory_mb,
        };
      }
    } catch (error) {
      console.warn('[WASM] Failed to get performance stats:', error);
    }

    return { used: 0, total: 0 };
  }

  isInitialized(): boolean {
    return this.wasmModule !== null;
  }
}

// Create a singleton instance
export const wasmService = new WasmService();

// Utility functions for log processing
export const logUtils = {
  /**
   * Split large log content into chunks for processing
   */
  chunkContent(content: string, chunkSize: number = 10000): string[] {
    const lines = content.split('\n');
    const chunks: string[] = [];

    for (let i = 0; i < lines.length; i += chunkSize) {
      chunks.push(lines.slice(i, i + chunkSize).join('\n'));
    }

    return chunks;
  },

  /**
   * Estimate processing time based on content size
   */
  estimateProcessingTime(contentLength: number): number {
    // Rough estimate: 1ms per 1KB of content
    return Math.max(100, contentLength / 1024);
  },

  /**
   * Format log level for display
   */
  formatLogLevel(level?: string): string {
    if (!level) return 'UNKNOWN';
    return level.toUpperCase();
  },

  /**
   * Get color class for log level
   */
  getLogLevelClass(level?: string): string {
    if (!level) return 'log-level-debug';

    switch (level.toUpperCase()) {
      case 'ERROR':
      case 'ERR':
        return 'log-level-error';
      case 'WARN':
      case 'WARNING':
        return 'log-level-warning';
      case 'INFO':
        return 'log-level-info';
      case 'DEBUG':
      case 'DBG':
      default:
        return 'log-level-debug';
    }
  },

  /**
   * Parse timestamp from log line
   */
  parseTimestamp(line: string): Date | null {
    // Common timestamp patterns
    const patterns = [
      /\d{4}-\d{2}-\d{2}[T ]\d{2}:\d{2}:\d{2}(?:\.\d{3})?(?:Z|[+-]\d{2}:\d{2})?/,
      /\d{2}\/\d{2}\/\d{4} \d{2}:\d{2}:\d{2}/,
      /\d{2}-\d{2}-\d{4} \d{2}:\d{2}:\d{2}/,
    ];

    for (const pattern of patterns) {
      const match = line.match(pattern);
      if (match) {
        const date = new Date(match[0]);
        if (!isNaN(date.getTime())) {
          return date;
        }
      }
    }

    return null;
  },
};